<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet"
        integrity="sha384-T3c6CoIi6uLrA9TneNEoa7RxnatzjcDSCmG1MXxSR1GAsXEV/Dwwykc2MPK8M2HN" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-C6RzsynM9kWDrMNeT87bh95OGNyZPhcTNXj1NW7RuBCsyN/o0jlpcV8Qyq46cDfL"
        crossorigin="anonymous"></script>
    <script src="https://code.highcharts.com/highcharts.js"></script>
    <script src="https://code.highcharts.com/highcharts-more.js"></script>

    <script src="https://code.highcharts.com/modules/accessibility.js"></script>
    <link rel="stylesheet" href="https://js.arcgis.com/4.28/esri/themes/light/main.css" />
    <script src="https://js.arcgis.com/4.28/"></script>
    <style>
        html,
        body {
            background-image: url('wxbackground.png');
            background-size: cover;
            height: 100%;
            /* Make sure the body takes full viewport height */
        }

        .h-100 {
            height: 100%;
            /* Sets the height to fill the container */
        }

        .h-66 {
            height: 66.66%;
            /* Approximately 2/3rds height */
        }

        .h-33 {
            height: 33.33%;
            /* Approximately 1/3rd height */
        }

        .jumbotron {
            /* backdrop-filter: blur(5px); */

            background: rgba(0, 0, 0, 0.5);
            border: 0px solid #fff;
            color: #ffffff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0px 4px 6px 0px rgba(0, 0, 0, 0.1);
        }

        .jumbotron2 {
            display: flex;
            /* Use flexbox */
            flex-direction: row;
            /* Align children in a row */
            align-items: center;
            /* Center items vertically */
            justify-content: start;
            /* Align items to the start of the container */
            background: rgba(0, 0, 0, 0.701);
            border: 0px solid #fff;
            color: #ffffff;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0px 4px 6px 0px rgba(0, 0, 0, 0.1);
        }

        .jumbotron h2 {
            font-weight: 700;
        }

        .jumbotron p {
            color: #ffffff;
        }

        .padding-10 {
            padding: 5px;
            margin: 0px
                /* Adjust as needed */
        }

        #forecastDiv {
            bottom: 0;
            /* semi-transparent black */
            color: white;
            display: flex;
            justify-content: center;
            height: 100%;
            /* or set a specific height */
            max-height: 100%;
            /* Optional: to ensure it doesn't grow beyond the parent container */
            overflow-y: auto;
            /* Adds a vertical scrollbar if the content overflows */
        }

        #hourlyDiv {
            bottom: 0;
            display: flex;
            justify-content: center;
            height: 100%;
            margin: 0;
            overflow: auto;
            width: 100%;
        }

        #uavDiv {
            bottom: 0;
            display: flex;
            justify-content: center;
            height: 100%;
            margin: 0;
            overflow: hidden;
            width: 100%;
        }

        #precipDiv {
            bottom: 0;
            display: flex;
            justify-content: center;
            height: 100%;
            margin: 0;
            overflow: hidden;
            width: 100%;
        }

        .forecast-item {
            margin: 0 10px;
            text-align: center;
        }

        .arrow-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 25px;
            /* Adjust width as needed */
        }

        .arrow {
            background-color: transparent;
            border: none;
            color: #ffffffae;
            font-size: 36px;
            cursor: pointer;
            margin: 5px 0;
            /* Reduce margin if necessary */
        }

        #upArrow {
            top: 10px;
            right: 10px;
        }

        #downArrow {
            bottom: 10px;
            right: 10px;
        }

        .spinner-border {
            width: 3rem;
            height: 3rem;
        }



        .card-body .background-image {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-size: cover;
            opacity: 0.5;
            /* Adjust the opacity as needed */
            z-index: -1;
        }

        .card-body {
            position: relative;
            z-index: 1;
        }
    </style>
</head>

<body>
    <div class="container-fluid h-100">
        <div class="row h-66">
            <div class="container padding-10 col-md-8">
                <div class="jumbotron h-100">
                    <div id="viewDiv" class="h-100">
                    </div>
                </div>
            </div>
            <div class="container padding-10 col-md-4">
                <div class="jumbotron h-100">
                    <div class="h-100">
                        <div id="initialtext" class="text-center">
                            Select a location on the map</div>
                        <div id="loadingIndicator" class="text-center d-none">
                            <div class="spinner-border text-custom" role="status">
                                <span class="sr-only"></span>
                            </div>
                        </div>
                        <div id='hiddendiv' class="container-fluid d-none">
                            <div class="row">
                                <div id="detailDiv" class="col-md-12">
                                </div>
                                <hr>
                            </div>
                            <div class="row">
                                <div class="col-md-12">
                                    <div id="currentDiv" class="col-md-12">

                                        <div class="weather-stats">
                                            <table style="width: 100%;">
                                                Current Conditions
                                                <tbody>
                                                    <tr>
                                                        <td style="width: 10%;"><img src="temp-icon.svg"
                                                                alt="Temperature" style="width: 50px; height: auto;" />
                                                        </td>
                                                        <td id="temperature" style="text-align: center;"></td>
                                                        <td style="width: 10%;"><img src="wind-icon.svg"
                                                                alt="Wind Speed" style="width: 50px; height: auto;" />
                                                        </td>
                                                        <td id="wind" style="text-align: center;"></td>
                                                    </tr>
                                                    <tr>
                                                        <td style="width: 10%;"><img src="gust-icon.svg" alt="Wind Gust"
                                                                style="width: 50px; height: auto;" /></td>
                                                        <td id="gust" style="text-align: center;"></td>
                                                        <td style="width: 10%;"><img src="fire-icon.svg"
                                                                alt="Fire Condition"
                                                                style="width: 50px; height: auto;" /></td>
                                                        <td id="fire" style="text-align: center;"></td>
                                                    </tr>
                                                    <tr>
                                                        <td style="width: 10%;"><img src="cloud-icon.svg"
                                                                alt="Cloud Cover" style="width: 50px; height: auto;" />
                                                        </td>
                                                        <td id="cloud" style="text-align: center;"></td>
                                                        <td style="width: 10%;"><img src="rain-icon.svg"
                                                                alt="Precipitation"
                                                                style="width: 50px; height: auto;" /></td>
                                                        <td id="rain" style="text-align: center;"></td>
                                                    </tr>
                                                </tbody>
                                            </table>

                                        </div>
                                    </div>
                                </div>
                            </div>
                            <hr>
                            Expected Conditions
                            <div class="row">
                                <div class="col-md-4">
                                    <div id="svg-fire-div">
                                        <!-- Initial SVG (embedded or via an img tag) -->
                                        <img src="fireoff.svg" id="svg-fire">
                                    </div>
                                </div>
                                <div class="col-md-4">
                                    <div id="svg-heat-div">
                                        <!-- Initial SVG (embedded or via an img tag) -->
                                        <img src="heatoff.svg" id="svg-heat">
                                    </div>
                                </div>
                                <div class="col-md-4">
                                    <div id="svg-tropical-div">
                                        <!-- Initial SVG (embedded or via an img tag) -->
                                        <img src="tropicaloff.svg" id="svg-tropical">
                                    </div>
                                </div>
                            </div>

                            <div class="row">
                                <div class="col-md-4">
                                    <div id="svg-rain-div">
                                        <!-- Initial SVG (embedded or via an img tag) -->
                                        <img src="rainoff.svg" id="svg-rain">
                                    </div>
                                </div>
                                <div class="col-md-4">
                                    <div id="svg-storm-div">
                                        <!-- Initial SVG (embedded or via an img tag) -->
                                        <img src="stormoff.svg" id="svg-storm">
                                    </div>
                                </div>
                                <div class="col-md-4">
                                    <div id="svg-snow-div">
                                        <!-- Initial SVG (embedded or via an img tag) -->
                                        <img src="snowoff.svg" id="svg-snow">
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <div class="row h-33">
            <div class="container padding-10 col-md-12">
                <div class="jumbotron2 h-100">
                    <div class="arrow-container">
                        <button id="upArrow" class="arrow">&#8593;</button> <!-- Up arrow -->
                        <button id="downArrow" class="arrow">&#8595;</button> <!-- Down arrow -->
                    </div>
                    <div id="hourlyDiv" class="h-100">
                        <!-- Hourly content here -->
                    </div>
                    <div id="forecastDiv" class="h-100 d-none">
                        <!-- Forecast content here -->
                    </div>

                    <div id="uavDiv" class="h-100 d-none">
                        <!-- Hourly content here -->
                    </div>
                    <div id="precipDiv" class="h-100 d-none">
                        <!-- Hourly content here -->
                    </div>
                </div>


            </div>
        </div>
    </div>

    </div>
</body>
<script>
    let previousPointGraphic
    require([
        "esri/config",
        "esri/Map",
        "esri/views/MapView",
        "esri/Graphic",
        "esri/geometry/Point",
        "esri/layers/MapImageLayer"
    ], function (esriConfig, Map, MapView, Graphic, Point, MapImageLayer) {
        esriConfig.portalUrl = "https://arcportal-ucop-corps.usace.army.mil/s0portal";
        esriConfig.request.trustedServers.push("https://arcportal-ucop-corps.usace.army.mil/s0portal");
        var map = new Map({
            basemap: "streets-night-vector" // You can change the basemap here
        });

        var view = new MapView({
            container: "viewDiv", // Reference to the view div created in HTML
            map: map,
            zoom: 4, // Sets zoom level based on scale
            center: [-98, 39] // Sets center point of view using longitude,latitude
        });
        //Add radar layer to map
        var radarLayer = new MapImageLayer({
            url: "https://mapservices.weather.noaa.gov/eventdriven/rest/services/radar/radar_base_reflectivity/MapServer"

        });
        var mapLayer = new MapImageLayer({
            url: "https://mapservices.weather.noaa.gov/vector/rest/services/outlooks/natl_fcst_wx_chart/MapServer"

        });
        map.add(mapLayer);
        map.add(radarLayer);
        view.on("click", async function (event) {
            document.getElementById('initialtext').innerHTML = '';
            document.getElementById('loadingIndicator').classList.remove('d-none');

            document.getElementById("svg-snow").src = "snowoff.svg";
            document.getElementById("svg-storm").src = "stormoff.svg";
            document.getElementById("svg-rain").src = "rainoff.svg";
            document.getElementById("svg-fire").src = "fireoff.svg";
            document.getElementById("svg-heat").src = "heatoff.svg";
            document.getElementById("svg-tropical").src = "tropicaloff.svg";
        

            const point = {
                type: "point",
                longitude: event.mapPoint.longitude,
                latitude: event.mapPoint.latitude
            };

            const markerSymbol = {
                type: "simple-marker",
                color: [226, 119, 40],
                outline: {
                    color: [255, 255, 255],
                    width: 2
                }
            };

            const pointGraphic = new Graphic({
                geometry: point,
                symbol: markerSymbol
            });

            if (previousPointGraphic) {
                view.graphics.remove(previousPointGraphic);
            }

            view.graphics.add(pointGraphic);
            previousPointGraphic = pointGraphic;

            var lat = event.mapPoint.latitude;
            var lon = event.mapPoint.longitude;

            try {
                // Run both getRegion and getGridpoint simultaneously
                const [regionData, gridpointData] = await Promise.all([
                    getRegion(lat, lon),
                    getGridpoint(lat, lon)
                ]);
                const { forecastUrl, forecastHourlyUrl } = gridpointData;
                const detcontainer = document.getElementById('detailDiv');

                detcontainer.innerHTML = `<h4>${regionData.address.City}, ${regionData.address.Region}</h4>`

                // Now that both are complete, fetch the forecast data
                const dailyForecastData = await getForecast(forecastUrl);
                //console.log('Daily Fetched')
                const hourlyForecastData = await getForecast(forecastHourlyUrl);
                console.log('Hourly Fetched')

                const container = document.getElementById('forecastDiv');
                container.innerHTML = '';

                dailyForecastData['periods'].forEach(forecast => {
                    const forecastDiv = document.createElement('div');

                    // Add HTML content
                    forecastDiv.innerHTML = `
<div class="card text-white bg-dark mb-3" style="max-width: 18rem;">
  <div class="card-header">${forecast.name}</div>
  <div class="card-body">
    <div class="background-image" style="background-image: url(${forecast.icon}); background-size: cover"></div>
    <h5 class="card-title">${forecast.shortForecast}</h5>
    <p class="card-text">${forecast.temperature} 째${forecast.temperatureUnit}<br>
    Wind: ${forecast.windSpeed} ${forecast.windDirection}
  </div>
</div>
`;
                    // Append only day items
                    if (forecast.isDaytime) {
                        container.appendChild(forecastDiv);
                    }
                });


                let temperature = hourlyForecastData['temperature']['values'].map(item => {
                    let date = new Date(item.validTime.split("/")[0]); // Parsing the date
                    return [date.getTime(), item.value * (9 / 5) + 32];
                });
                let maxtemperature = hourlyForecastData['maxTemperature']['values'].map(item => {
                    let date = new Date(item.validTime.split("/")[0]); // Parsing the date
                    return [date.getTime(), item.value];
                });
                let skyCover = hourlyForecastData['skyCover']['values'].map(item => {
                    let date = new Date(item.validTime.split("/")[0]); // Parsing the date
                    return [date.getTime(), item.value];
                });
                let windSpeed = hourlyForecastData['windSpeed']['values'].map(item => {
                    let date = new Date(item.validTime.split("/")[0]); // Parsing the date
                    return [date.getTime(), item.value];
                });
                let windGust = hourlyForecastData['windGust']['values'].map(item => {
                    let date = new Date(item.validTime.split("/")[0]); // Parsing the date
                    return [date.getTime(), item.value];
                });

                let probabilityOfPrecipitation = hourlyForecastData['probabilityOfPrecipitation']['values'].map(item => {
                    let date = new Date(item.validTime.split("/")[0]); // Parsing the date
                    return [date.getTime(), item.value];
                });
                let quantitativePrecipitation = hourlyForecastData['quantitativePrecipitation']['values'].map(item => {
                    let date = new Date(item.validTime.split("/")[0]); // Parsing the date
                    return [date.getTime(), item.value * 0.0393701];
                });
                let iceAccumulation = hourlyForecastData['iceAccumulation']['values'].map(item => {
                    let date = new Date(item.validTime.split("/")[0]); // Parsing the date
                    return [date.getTime(), item.value * 0.0393701];
                });
                let snowfallAmount = hourlyForecastData['snowfallAmount']['values'].map(item => {
                    let date = new Date(item.validTime.split("/")[0]); // Parsing the date
                    return [date.getTime(), item.value * 0.0393701];
                });
                let ceilingHeight = hourlyForecastData['ceilingHeight']['values'].map(item => {
                    let date = new Date(item.validTime.split("/")[0]); // Parsing the date
                    return [date.getTime(), Math.abs(item.value) * 3.28084];
                });
                let visibility = hourlyForecastData['visibility']['values'].map(item => {
                    let date = new Date(item.validTime.split("/")[0]); // Parsing the date
                    return [date.getTime(), item.value * 0.000621371];
                });
                let grasslandFireDangerIndex = hourlyForecastData['grasslandFireDangerIndex']['values'].map(item => {
                    let date = new Date(item.validTime.split("/")[0]); // Parsing the date
                    return [date.getTime(), item.value];
                });
                let lightningActivityLevel = hourlyForecastData['lightningActivityLevel']['values'].map(item => {
                    let date = new Date(item.validTime.split("/")[0]); // Parsing the date
                    return [date.getTime(), item.value];
                });
                let apparentTemperature = hourlyForecastData['apparentTemperature']['values'].map(item => {
                    let date = new Date(item.validTime.split("/")[0]); // Parsing the date
                    return [date.getTime(), item.value];
                });

                //Get temperature that is closest to now
                let now = Date.now();
                let closesttemp = temperature.reduce(function (prev, curr) {
                    return (Math.abs(curr[0] - now) < Math.abs(prev[0] - now) ? curr : prev);
                });

                let closestcloud = skyCover.reduce(function (prev, curr) {
                    return (Math.abs(curr[0] - now) < Math.abs(prev[0] - now) ? curr : prev);
                });
                let closestrain = probabilityOfPrecipitation.reduce(function (prev, curr) {
                    return (Math.abs(curr[0] - now) < Math.abs(prev[0] - now) ? curr : prev);
                });
                let closestfire
                try {
                    closestfire = grasslandFireDangerIndex.reduce(function (prev, curr) {
                        return (Math.abs(curr[0] - now) < Math.abs(prev[0] - now) ? curr : prev);
                    });

                    // Additional code to work with closestfire
                } catch (error) {
                    // Handle the error
                    closestfire = [0, 0]    // Here, you can define how your program should behave in case of an error.
                    // For example, setting closestfire to a default value, or logging the error, etc.
                }

                let closestwind = windSpeed.reduce(function (prev, curr) {
                    return (Math.abs(curr[0] - now) < Math.abs(prev[0] - now) ? curr : prev);
                });

                let closestgust = windGust.reduce(function (prev, curr) {
                    return (Math.abs(curr[0] - now) < Math.abs(prev[0] - now) ? curr : prev);
                });
                // Update the content of the div element
                document.getElementById('loadingIndicator').classList.add('d-none');

                document.getElementById('hiddendiv').classList.remove('d-none');

                document.getElementById('temperature').innerText = closesttemp[1] + ' 째F';
                document.getElementById('wind').innerText = Math.round(closestwind[1], 0) + ' mph';
                document.getElementById('gust').innerText = Math.round(closestgust[1], 0) + ' mph';
                document.getElementById('fire').innerText = closestfire[1] + ' FDI';
                document.getElementById('cloud').innerText = closestcloud[1] + '%';
                document.getElementById('rain').innerText = closestrain[1] + '%';






                if (snowfallAmount.some(item => item[1] > 0)) {
                    switchSnowSVG();
                }
                if (iceAccumulation.some(item => item[1] > 0)) {
                    switchSnowSVG();
                }
                if (quantitativePrecipitation.some(item => item[1] > 0)) {
                    switchRainSVG();
                }
                if (probabilityOfPrecipitation.some(item => item[1] > 0)) {
                    switchRainSVG();
                }
                if (lightningActivityLevel.some(item => item[1] > 1)) {
                    switchStormSVG();
                }
                if (grasslandFireDangerIndex.some(item => item[1] > 40)) {
                    switchFireSVG();
                }

                let defaultVisibility = 15; // Default value for visibility
                let defaultCloudCeiling = 65620; // Default value for cloud ceiling

                function backfillData(referenceData, targetData, defaultValue) {
                    for (let i = 0; i < referenceData.length; i++) {
                        // Check if the element exists in targetData
                        if (!targetData[i]) {
                            // If it doesn't exist, create it with the timestamp from referenceData and the defaultValue


                            targetData[i] = [referenceData[i][0], defaultValue];
                        } else if (targetData[i][1] == null) {
                            // If the element exists but the value is null, set the default value
                            targetData[i][1] = defaultValue;
                        }
                    }
                }


                backfillData(temperature, visibility, defaultVisibility);
                console.log(ceilingHeight)
                backfillData(temperature, ceilingHeight, defaultCloudCeiling);
                console.log(ceilingHeight)

                //sort visibility by timestamp
                visibility.sort(function (a, b) {
                    return a[0] - b[0];
                });
                ceilingHeight.sort(function (a, b) {
                    return a[0] - b[0];
                });





                Highcharts.chart('hourlyDiv', {
                    legend: {
                        itemStyle: {
                            color: 'white' // Change this to the desired color
                        }
                    },
                    credits: {
                        enabled: false
                    },
                    chart: {
                        type: 'line',
                        zoomType: 'xy',
                        backgroundColor: '#f9f8f800',
                        width: null,
                        height: null

                    },
                    title: {
                        text: 'Hourly Forecast',
                        style: {
                            color: 'white'
                        }
                    },
                    xAxis: {
                        type: 'datetime',
                        plotLines: [{
                            value: Date.now(),
                            color: 'white',
                            width: 2,
                            zIndex: 5,
                            label: {
                                text: 'Now',
                                align: 'center',
                                style: {
                                    color: 'white'
                                }
                            }
                        }],
                        title: {
                            text: null
                        },
                        labels: {
                            style: {
                                color: '#FFFFFF' // white y-axis labels
                            }
                        }
                    },
                    yAxis: [{
                        title: {
                            text: 'Temperature (째F)',
                            style: {
                                color: 'red'
                            }
                        },
                        labels: {
                            style: {
                                color: 'red' // white y-axis labels
                            }
                        }
                    }, { // Secondary yAxis for Wind Speed
                        title: {
                            text: 'Wind Speed',
                            style: {
                                color: 'green'
                            }
                        },
                        labels: {
                            format: '{value} mph',
                            style: {
                                color: 'green'
                            },

                        },
                        opposite: true,
                        max: 80,
                    }, { // Tertiary yAxis for Probability of Precipitation
                        title: {
                            text: 'Probability of Precipitation',
                            style: {
                                color: 'white'
                            }
                        },
                        labels: {
                            format: '{value} %',
                            style: {
                                color: 'white'
                            }
                        },
                        max: 100,
                        endOnTick: false,
                        opposite: true
                    }],
                    series: [
                        {
                            name: 'Temperature',
                            data: temperature,
                            tooltip: {
                                valueSuffix: ' 째F'
                            },
                            color: 'red',
                            zones: [
                                {
                                    value: 32, // Up to 32 degrees, use white color
                                    color: 'white'
                                },
                                {
                                    color: 'red' // Above 95 degrees, use red color
                                }

                            ]
                        },
                        {
                            name: 'Wind Speed',
                            type: 'spline',
                            color: 'green',
                            lineWidth: 2,
                            yAxis: 1,
                            dashStyle: 'dash',
                            data: windSpeed,
                            tooltip: {
                                valueSuffix: ' mph'
                            },
                            zIndex: 1
                        }, {
                            name: 'Probability of Precipitation',
                            type: 'column',
                            color: 'rgba(255, 255, 255, 0.5)',
                            data: probabilityOfPrecipitation,
                            yAxis: 2,
                            tooltip: {
                                valueSuffix: ' %'
                            },
                            zIndex: 0
                        }
                    ]
                });



                // Function to find value by timestamp in a dataset
                function findValueByTimestamp(timestamp, dataset) {
                    let entry = dataset.find(pair => pair[0] === timestamp);
                    return entry ? entry[1] : null;
                }

                // Create plotBands array
                let plotBands = [];
                for (let i = 0; i < visibility.length; i++) {
                    let timestamp = visibility[i][0];
                    let vis = visibility[i][1];
                    let wind = findValueByTimestamp(timestamp, windGust);
                    let cloudCeiling = findValueByTimestamp(timestamp, ceilingHeight);

                    // Check if all conditions are met
                    if (wind < 21 && vis > 5 && cloudCeiling > 5000) {
                        plotBands.push({
                            from: timestamp,
                            to: timestamp + 3600000, // Assuming 1 hour intervals, adjust as needed
                            color: 'green'
                        });
                    }
                    else {
                        plotBands.push({
                            from: timestamp,
                            to: timestamp + 3600000, // Assuming 1 hour intervals, adjust as needed
                            color: 'red'
                        });
                    }
                }

                Highcharts.chart('uavDiv', {
                    legend: {
                        itemStyle: {
                            color: 'white' // Change this to the desired color
                        }
                    },
                    chart: {
                        type: 'line',
                        zoomType: 'xy',
                        backgroundColor: '#f9f8f800',
                        width: null,
                        height: null

                    },
                    credits: {
                        enabled: false
                    },
                    title: {
                        text: 'UAV Operations',
                        style: {
                            color: 'white'
                        }
                    },
                    xAxis: {
                        type: 'datetime',
                        title: {
                            text: null
                        },
                        labels: {
                            style: {
                                color: '#FFFFFF' // white y-axis labels
                            }
                        },
                        plotBands: plotBands
                    },
                    yAxis: [{
                        title: {
                            text: 'Visibility (miles)',
                            style: {
                                color: 'red'
                            }
                        },
                        labels: {
                            style: {
                                color: 'red' // white y-axis labels
                            }
                        },
                        max: 15
                    }, { // Secondary yAxis for Wind Speed
                        title: {
                            text: 'Wind Gust',
                            style: {
                                color: 'green'
                            }
                        },
                        labels: {
                            format: '{value} mph',
                            style: {
                                color: 'green'
                            },

                        },
                        opposite: true,
                    }, { // Tertiary yAxis for Probability of Precipitation
                        title: {
                            text: 'Ceiling Height (ft)',
                            style: {
                                color: 'rgba(0, 77, 100)'
                            }
                        },
                        labels: {
                            format: '{value/1000}k',
                            style: {
                                color: 'rgba(0, 77, 100)'
                            }
                        },
                        endOnTick: false,
                        opposite: true
                    }],
                    series: [
                        {
                            name: 'Visibility',
                            data: visibility,

                        },
                        {
                            name: 'Wind Gust',
                            type: 'spline',
                            color: 'green',
                            lineWidth: 2,
                            yAxis: 1,
                            dashStyle: 'dash',
                            data: windGust,
                            tooltip: {
                                valueSuffix: ' mph'
                            },
                            zIndex: 1
                        }, {
                            name: 'Ceiling',
                            type: 'line',
                            color: 'rgba(0, 77, 100)',
                            data: ceilingHeight,
                            yAxis: 2,
                            tooltip: {
                                valueSuffix: ' ft'
                            },
                            zIndex: 0
                        }
                    ]
                });

                Highcharts.chart('precipDiv', {
                    legend: {
                        itemStyle: {
                            color: 'white' // Change this to the desired color
                        }
                    },
                    credits: {
                        enabled: false
                    },
                    chart: {
                        type: 'line',
                        zoomType: 'xy',
                        backgroundColor: '#f9f8f800',
                        width: null,
                        height: null

                    },
                    title: {
                        text: 'Precipitation Accumulation',
                        style: {
                            color: 'white'
                        }
                    },
                    xAxis: {
                        type: 'datetime',
                        plotLines: [{
                            value: Date.now(),
                            color: 'white',
                            width: 2,
                            zIndex: 5,
                            label: {
                                text: 'Now',
                                align: 'center',
                                style: {
                                    color: 'white'
                                }
                            }
                        }],
                        title: {
                            text: null
                        },
                        labels: {
                            style: {
                                color: '#FFFFFF' // white y-axis labels
                            }
                        }
                    },
                    yAxis: [{
                        title: {
                            text: 'Total Precip (in)',
                            style: {
                                color: 'yellow'
                            }
                        },
                        min: 0,
                        labels: {
                            style: {
                                color: 'yellow' // white y-axis labels
                            }
                        }
                    }, { // Secondary yAxis for Wind Speed
                        title: {
                            text: 'Snow (in)',
                            style: {
                                color: 'white'
                            }
                        },
                        labels: {
                            format: '{value}',
                            style: {
                                color: 'white'
                            },

                        },
                        min: 0,
                        opposite: true,
                    }, { // Tertiary yAxis for Ice
                        title: {
                            text: 'Ice (in)',
                            style: {
                                color: '#8EE5EE'
                            }
                        },
                        min: 0, // Ensure this is correctly set for the yAxis of the Ice data
                        labels: {
                            format: '{value}',
                            style: {
                                color: '#8EE5EE'
                            }
                        },
                        endOnTick: false,
                        opposite: true
                    }],
                    series: [
                        {
                            name: 'Rain',
                            type: 'spline',
                            color: 'yellow',
                            data: quantitativePrecipitation,

                        },
                        {
                            name: 'Snow',
                            type: 'spline',
                            color: 'white',
                            lineWidth: 1,
                            yAxis: 1,
                            data: snowfallAmount,

                            zIndex: 1
                        }, {
                            name: 'Ice',
                            type: 'spline',
                            color: '#8EE5EE',
                            data: iceAccumulation,
                            yAxis: 0,
                        }
                    ]
                });


            } catch (error) {
                console.error('Error fetching forecast:', error);
            }
        });

    });







































    async function getRegion(lat, lon) {
        return new Promise((resolve, reject) => {
            const xhr = new XMLHttpRequest();
            const url = `https://geocode.arcgis.com/arcgis/rest/services/World/GeocodeServer/reverseGeocode?location=${lon},${lat}&forStorage=false&f=pjson`;
            xhr.open("GET", url, true);

            xhr.onload = function () {
                if (xhr.status >= 200 && xhr.status < 300) {
                    resolve(JSON.parse(xhr.responseText));
                } else {
                    reject(new Error(`HTTP error! Status: ${xhr.status}`));
                }
            };

            xhr.onerror = function () {
                reject(new Error("Network error"));
            };

            xhr.send();
        });
    }

    async function getGridpoint(lat, lon) {
        return new Promise((resolve, reject) => {
            const xhr = new XMLHttpRequest();
            const url = `https://api.weather.gov/points/${lat},${lon}`;
            xhr.open("GET", url, true);

            xhr.onload = function () {
                if (xhr.status >= 200 && xhr.status < 300) {
                    const data = JSON.parse(xhr.responseText);
                    resolve({
                        forecastUrl: data.properties.forecast,
                        forecastHourlyUrl: data.properties.forecastGridData
                    });
                } else {
                    reject(new Error('Network response was not ok'));
                }
            };

            xhr.onerror = function () {
                reject(new Error("Network error"));
            };

            xhr.send();
        });
    }

    async function getForecast(forecastUrl, attempts = 0) {
        return new Promise((resolve, reject) => {
            const xhr = new XMLHttpRequest();
            xhr.open("GET", forecastUrl, true);

            xhr.onload = function () {
                if (xhr.status >= 200 && xhr.status < 300) {
                    var data = JSON.parse(xhr.responseText);
                    resolve(data['properties']);
                } else {
                    if (attempts < 5) {
                        // Retry the function
                        resolve(getForecast(forecastUrl, attempts + 1));
                    } else {
                        // Reject after 5 attempts
                        reject(new Error('Network response was not ok'));
                    }
                }
            };

            xhr.onerror = function () {
                if (attempts < 5) {
                    // Retry the function
                    resolve(getForecast(forecastUrl, attempts + 1));
                } else {
                    // Reject after 5 attempts
                    reject(new Error("Network error"));
                }
            };

            xhr.send();
        });
    }


    document.addEventListener('DOMContentLoaded', function () {
        var upArrow = document.getElementById('upArrow');
        var downArrow = document.getElementById('downArrow');
        var divs = [
            document.getElementById('hourlyDiv'),
            document.getElementById('forecastDiv'),
            document.getElementById('uavDiv'),
            document.getElementById('precipDiv')
        ];
        var currentDivIndex = 0;

        function toggleDivs() {
            divs[currentDivIndex].classList.add('d-none');
            currentDivIndex = (currentDivIndex + 1) % divs.length;
            divs[currentDivIndex].classList.remove('d-none');
        }

        upArrow.addEventListener('click', toggleDivs);
        downArrow.addEventListener('click', toggleDivs);
    });

    function switchSnowSVG() {
        // Assuming the new SVG is also an external file
        var newSvgPath = "snowon.svg";
        document.getElementById("svg-snow").src = newSvgPath;
    }
    function switchStormSVG() {
        // Assuming the new SVG is also an external file
        var newSvgPath = "stormon.svg";
        document.getElementById("svg-storm").src = newSvgPath;
    }
    function switchRainSVG() {
        // Assuming the new SVG is also an external file
        var newSvgPath = "rainon.svg";
        document.getElementById("svg-rain").src = newSvgPath;
    }
    function switchFireSVG() {
        // Assuming the new SVG is also an external file
        var newSvgPath = "fireon.svg";
        document.getElementById("svg-fire").src = newSvgPath;
    }
    function switchHeatSVG() {
        // Assuming the new SVG is also an external file
        var newSvgPath = "heaton.svg";
        document.getElementById("svg-heat").src = newSvgPath;
    }
    function switchTropicalSVG() {
        // Assuming the new SVG is also an external file
        var newSvgPath = "tropicalon.svg";
        document.getElementById("svg-tropical").src = newSvgPath;
    }



</script>

</html>